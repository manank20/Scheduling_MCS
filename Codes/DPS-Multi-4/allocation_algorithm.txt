Algorithm for allocation of tasks to cores:
Input: Taskset T with M tasks and N cores.
Output: Minimum number of cores needed and set of subtasks allocated to each core.
Assumptions:

Algorithm:
Step 1: Sort M tasks in non-decreasing order of their periods.
Step 2: shutdown_tasks, non_shutdown_tasks, non_shutdown_cores = find_shutdown_tasks(T)
Step 3: allocate_exceptional_tasks(T)
Step 4: allocate_non_shutdown_tasks(non_shutdown_tasks, non_shutdown_cores)                        
Step 5: allocate_shutdown_tasks(shutdown_tasks) 
Step 6: Output the minimum number of cores and the tasks allocated to each core.

------------------------------------------------------------------------------------------------------------------------
Algorithm find_shutdown_tasks:
Input: Taskset T with M tasks
Output: List of shutdown_tasks, non_shutdown_tasks and cores for non_shutdown_tasks
Assumptions:
Algorithm:
non_shutdown_utilisation = 0
for each task i in M
beginLoop
	for level x âˆˆ [0,4]
		i.util[x] = i.P/i.E[x]

    	if 2*i.P - 2*i.E[0] >= SDT then
        	shutdown_tasks = i
    	else
        	non_shutdown_tasks = i
        	non_shutdown_utilisation += i.util[0]
    	endif
endloop

shutdown_cores = [1 to (ceil)non_shutdown_utilisation]
return shutdown_tasks, non_shutdown_tasks and non_shutdown_cores

------------------------------------------------------------------------------------------------------------------------
Algorithm allocate_exceptional_tasks:
Input: Taskset T with M tasks and N processors
Output: Set of subtasks allocated to each processor
Assumptions: MAX_util array is already calculated.
Algorithm:
Initialise K to 1

for each task i in M:
beginLoop
    x = i.criticality_level
    flag = 1

    if i.util[x] > MAX_UTIL[x] then
        for criticality_level âˆˆ [0,x]
        if K.rem_util[level] < i.util[level] then
            flag = 0
            break
		endloop

        if flag = 0 then
            K = K+1
            if K > N then
            print "Insufficient number of cores"
                exit
            Repeat the process for same task i
        else
            flag = 0

        if schedulability conditions of core K satisfied after task i is allocated to core K then 
            flag = 1
            Allocate task i to core K
            Update the x factor and threshold criticality level of core K
            for criticality level âˆˆ [0,x]
                K.rem_util[level] = K.rem_util[level] - i.util[level]
        else
            Remove task i from core K.

        if flag = 0 then
            K = K+1
            if K > N:
                print "Insufficient number of cores"
                exit
            Repeat the process for same task i
endLoop

------------------------------------------------------------------------------------------------------------------------
Algorithm allocate_non_shutdown_tasks:
Input: List of non_shutdown_tasks and N processors.
Output: Set of non_shutdown subtasks allocated to each core.
Assumptions: All the exceptional tasks have already been allocated and removed from the taskset.

Algorithm:
K=1
for criticality level x = 4 to 0
beginLoop
    for task i âˆˆ shutdown_tasks with i.criticality = x
    beginLoop
        for criticality level âˆˆ [0,x]
            if K.rem_util[level] < i.util[level] then
                flag = 0
                break

        if flag = 0 then
            K = K+1
            if K > Number of non_shutdown_cores then
                Add one more core to the list.
            if K > N then
                print "Insufficient number of cores"
                exit
            Repeat the process for same task i
	    else 
            flag = 0           
            if total_utilisation of core K at level x < MAX Utilization at level x:
                if schedulability conditions of core K are satisfied after allocating task i to core K:
                    flag = 1
                    Allocate task i to core K
                    Update the x factor and threshold criticality level of core K
                    for criticality level  âˆˆ [0,x]
                        K.rem_util[level] = K.rem_util[level] - i.util[level]
            else
            	Remove task i from core K.

        	if flag = 0 then
            	K = K+1
            	if K > Number of non_shutdown_cores then
                    Add one more core to the list.
            	else if K > N then
                    print "Insufficient number of cores"
                    exit
           		Repeat the process for the same task i.
    endLoop
endLoop

------------------------------------------------------------------------------------------------------------------------


///// Proposed modification for implementing migration

add two sets, shutdownable cores and non shutdownable cores, and on decision
point, try to allocate it to non-shutdownable cores first, and if not possible,
then allocate it to shutdownable core.

** but then wont those one/more core become more utilized then others?


Algorithm allocate_shutdown_tasks_migration:
two sets CORES_S & CORES_NS

K = CORES_NS.next()
for criticality level x = 4 to 0
beginLoop
    for tasks i in non_shutdown_tasks with i.criticality = x
    beginLoop
        for criticality level in [0,x]
            if K.rem_util[level] < i.util[level] then
            flag = 0
            break
        
        if flag = 0 then
            K = CORES_NS.next()
            if K == NULL then
                K = CORES_S.next()
            if K == NULL then
                print "Insufficient number of cores"
                exit
            Repeat the process for same task i
        else
            flag = 0
            if total_utilisation of core K at level x < MAX Utilization at level x:
                if schedulability conditions of core K are satisfied after allocating task i to core k:
                    flag = 1
                    Allocate task i to core k
                    check if core K is SHutdown or not, and put in appropriate set
                    Update the x factor and threshold criticality level of core K
                    for criticality level in [0,x]
                        K.rem_util[level] = K.rem_util[level] - i.util[level]
            else
                Remove task i from core K 
                check if core K is SHutdown or not, and put in appropriate set

            if flag = 0 then         
                K = CORES_NS.next()
                if K == NULL then
                    K = CORES_S.next()
                if K == NULL then
                    print "Insufficient number of cores"
                exit
                Repeat the process for the same task i.
    endLoop
endLoop


to prove:- 
minimum cores, shutdownable cores m 
////////


Algorithm allocate_shutdown_tasks:
Input: List of shutdown_tasks and N processors.
Output: Set of shutdown subtasks allocated to each core.
Assumptions: All the exceptional tasks have already been allocated and removed from the taskset.

Algorithm:
K=1
for criticality level x = 4 to 0
beginLoop
    for taks i âˆˆ non_shutdown_tasks with i.criticality = x
    beginLoop
        for criticality level âˆˆ [0,x]
            if K.rem_util[level] < i.util[level] then
            flag = 0
            break

        if flag = 0 then
            K = K+1
            if K > N then
                print "Insufficient number of cores"
                exit
            Repeat the process for same task i
	    else 
            flag = 0           
            if total_utilisation of core K at level x < MAX Utilization at level x:
                if schedulability conditions of core K are satisfied after allocating task i to core K:
                    flag = 1
                    Allocate task i to core K
                    Update the x factor and threshold criticality level of core K
                    for criticality level  âˆˆ [0,x]
                        K.rem_util[level] = K.rem_util[level] - i.util[level]
            else
            	Remove task i from core K.

        	if flag = 0 then
            	K = K+1
            	else if K > N then
                    print "Insufficient number of cores"
                    exit
           		Repeat the process for the same task i.
    endLoop
endLoop

------------------------------------------------------------------------------------------------------------------------


