Scheduling algorithm for mixed-criticality taskset (4 criticality levels)

Input: Core, subtasks allocated to core.
Output: A schedule of all the jobs of tasks subject to DPS, DVFS and criticality change.
Assumptions: The taskset consists of the phase, deadline, criticality_level, WCET for each criticality level.
Algorithm for scheduling the taskset:
schedule_taskset():
Step 1: find_superhyperperiod(cores)
Step 2: Repeat until end of superhyperperiod
        beginLoop
        decision_point, decision_time = find_next_decision_point()

        if decision point = ARRIVAL then
            if new_job = DISCARDED then
                max_slack = find_max_slack(core, new_job.deadline)
                if max_slack > new_job.execution_time then
                    core.ready_queue.insert(new_job)
                    select_frequency(core)
                    core.schedule_new_job()
                else:
                    discarded_queue.insert(new_job)
            else:
                core.ready_queue.insert(new_job)
                new_job.util = Ci / Pi
                select_frequency(core)
                core.schedule_new_job()                     //Insert the job in the ready queue and schedule a new job in the core. If the curent executing job has a later deadline, preempt the currently executing job. Update the WCET counter to indicate whether criticality change is needed.

        if decision point = COMPLETION then  
            completed_job.util = cci / Pi
            core.remove_job_from_ready_queue()          //Remove job from ready queue.

            if core.ready_queue is empty then
                procrastination_interval = find_procrastination_interval()

                if procrastination_interval > SDT then
                    core.state = SHUTDOWN
                    core.next_invocation_time = curr_time + procrastination_interval
                else:
                    accommodate_discarded_jobs_in_ready_queue(core, discarded_queue)

            if core.ready_queue is not empty then:
                select_frequency(core)
                core.schedule_new_job()                 //Schedule the next job from the ready queue. 

        if decision point = TIMER_EXPIRY then
            core.state = ACTIVE                         
            core.ready_queue.insert(jobs)               //Insert the jobs already arrived in the ready queue.
            core.frequency = 1.00
            core.schedule_new_job()                     //Schedule a new job from the ready queue. 
        
        if decision point = CRIT_CHANGE then
            for each core c âˆˆ [0,N]
                c.criticality_level = c.criticality_level + 1
                c.insert_jobs_in_discarded_queue()
                accommodate_discarded_jobs_in_ready_queue(c, discarded_queue)
                select_frequency(c)
                c.schedule_new_job()

------------------------------------------------------------------------------------------------------------------------
Algorithm for finding the next decision point of the core.
Input: The subtasks list allocated to the core. 
Output: The decision point and time. The decision point can be ARRIVAL, COMPLETION, CRIT_CHANGE or TIMER_EXPIRY
find_next_decision_point():
    find arrival time of the next earliest arriving job.
    if core.state = ACTIVE then
        find completion time of currently executing job.
        find WCET_counter of currently executing job. 
    if core.state = SHUTDOWN then 
        find next_invocation_time of the core.
    
    next_decision_time = min(arrival_time, completion_time, WCET_counter, next_invocation_time)
    return next_decision_point, next_decision_time

------------------------------------------------------------------------------------------------------------------------
find_procrastination_interval():
Same as the DPS algorithm. 

------------------------------------------------------------------------------------------------------------------------
insert_discarded_jobs_in_ready_queue(core, discarded_queue):
    for each discarded_job in discarded_queue:
        if discarded_job âˆˆ core:
            max_slack = find_max_slack(core)

            if max_slack > discarded_job.execution_time then
                remove_job_from_discarded_queue()
                core.insert.ready_queue(discarded_job)
    
    for each discarded_job in discarded_queue:
        max_slack = find_max_slack(core)

        if max_slack > discarded_job.execution_time then
            remove_job_from_discarded_queue()
            core.insert.ready_queue(discarded_job)

------------------------------------------------------------------------------------------------------------------------
select_frequency():
if ready_queue has a discarded_job:
    core.frequency = MAX_FREQ
else:
    for each crit_level from curr_level to MAX:
        Calculate U_dyn = U_rq + U_low + U_high

        U_rq = Sum of util of jobs in ready_queue where util = rem_WCET[crit_level] / abs_D - curr_time
        U_low = Sum of util of lower priority jobs arriving in future where util = util[crit_level] * (abs_D - arrival_time) / period
        U_high = Sum of util of higher priority jobs arriving in future where util = util[crit_level]

        Select lowest frequency fi such that U_dyn <= fi/fmax



-----------------------------------------------------------------------------------------------------------------------



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 2023
For migration
check if number of shutdownable cores < x% of total cores (say 50%)
if yes then try to migrate tasks from the least utilized non-shutdown cores to the most utilized one
otherwise scheduling algorithm will be expo. complexity, if we try to check all cores max procrastination interval everytime



are we going to use migration of tasks of all criticality or only the less/least critical tasks? schedule tasks criticality wise?


ans:-
criticality change, util below threshold, core idling

only highest criticality job not migrated, all other can